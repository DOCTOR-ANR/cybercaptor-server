
/******************************************************/
/****         Predicates Declaration              *****/
/******************************************************/


/*Add local firewall rules to hosts*/
/*TODO : Add a host to networkServiceInfo */

primitive(vulExists(_host, _vulID, _program)).
primitive(vulProperty(_vulID, _range, _consequence)).
primitive(haclprimit(_src, _dst, _prot, _port)).
primitive(attackerLocated(_host)).
primitive(hasAccount(_principal, _host, _account)).
primitive(networkServiceInfo(_ip, _program, _protocol, _port, _user)).
primitive(installed(_h, _program)).
primitive(vulExists(_machine,_vulID,_program,_range,_consequence)).
primitive(isInVlan(_ip,_vlan)). /*The ip is in VLAN _vlan */
primitive(vlanToVlan(_vlan1,_vlan2,_protocol,_port)).
primitive(ipToVlan(_ip,_vlan,_protocol,_port)).
primitive(vlanToIP(_vlan,_ip,_protocol,_port)).

primitive(defaultLocalFilteringBehavior(_toip,_behavior)). /* allow / deny*/
primitive(localFilteringRule(_fromIP,_toIP,_port,_behavior)).

/*multi-interface*/
primitive(hasIP(_host,_IP)).



meta(cvss(_vulID, _ac)).

derived(ipInSameVLAN(_ip1,_ip2)).
derived(localAccessEnabled(_ip,_fromIP,port)).
derived(execCode(_host, _user)).
derived(netAccess(_ip,_protocol,_port)).
derived(canAccessHost(_host)).
derived(hacl(_src, _dst, _prot, _port)).

meta(attackGoal(_)).
meta(advances(_, _)).

/******************************************************/
/****         Tabling Predicates                  *****/
/*   All derived predicates should be tabled          */
/******************************************************/

:- table execCode/2.
:- table netAccess/3.
:- table canAccessHost/1.
:- table vulExists/5.
:- table hacl/4.
:- table ipInSameVLAN/2.
:- table localAccessEnabled/3.

/******************************************************/
/****         Interaction Rules                   *****/
/******************************************************/

/****** Section execCode ******
interaction_rule(
   (execCode(H, Perm) :-
	hasAccount(P, H, Perm)),
   rule_desc('Insider threat', 1)).
*/
/*
interaction_rule(
  (execCode(Host, Privilege) :-
    networkServiceInfo(IP, _, _, _, Privilege),
    hasIP(Host,IP),
	execCode(Host, root)),
  rule_desc('Root has all privileges',
  1.0)).
 */ 
interaction_rule(
  (execCode(Host, root) :-
	execCode(Host, _Perm2),
	vulExists(Host, _, Software, localExploit, privEscalation),
	_Perm2 \== root),
  rule_desc('local exploit',
  1.0)).

interaction_rule(
  (execCode(H, 'user') :-
	vulExists(H, _, Software, remoteExploit, privEscalation),
	hasIP(H,IP),
	networkServiceInfo(IP, Software, Protocol, Port, 'user'),
	netAccess(IP, Protocol, Port)),
  rule_desc('remote exploit of a server program',
  1.0)).


interaction_rule(
  (netAccess(IP2, Protocol, Port) :-
	execCode(H1, _),  /* Any permission level */
/*	advances(H1, H2), */
	hasIP(H1,IP1),
/*      hasIP(H2,IP2), */
	hasIP(H2, IP2),
	H1 \== H2,
    	hacl(IP1, IP2, Protocol, Port)),
  rule_desc('multi-hop access',
  0.5)).

/* Change rules : attackerLocated
interaction_rule(
  (netAccess(IP, Protocol, Port) :-
	attackerLocated(Zone),
	hacl(Zone, IP, Protocol, Port)),
  rule_desc('direct IP access',
  1.0)).

interaction_rule(
  (netAccess(IP, Protocol, Port) :-
	attackerLocated(IP)),
  rule_desc('direct on-host access',
  1.0)).
*/

interaction_rule(
  (execCode(Host, root) :-
	attackerLocated(Host)),
  rule_desc('Attacker is root on his machine',
  1.0)).


/****** Section canAccessHost ******/
interaction_rule(
  (canAccessHost(H) :-
	execCode(H, _Perm)),
  rule_desc('Access a host through executing code on the machine',
  1.0)).




/*interaction_rule((vulExists(H, ID, Sw, Range, Consequence):-
	        vulExists(H, ID, Sw),
		vulProperty(ID, Range, Consequence)),
             rule_desc('',
             1)).
*/


interaction_rule(
    (hacl(IP1,IP2,Protocol,Port) :-
        haclprimit(IP1,IP2,Protocol,Port)),
    rule_desc('The HACL has been defined manually',
   1.0)). 

/*VLAN interaction rules*/
interaction_rule(
    (ipInSameVLAN(IP1,IP2) :-
        isInVlan(IP1,Vlan),
        IP1 \== IP2 ,
        isInVlan(IP2,Vlan)),
    rule_desc('Interfaces are in the same vlan',
   1.0)).
   
/*VLAN interaction rules*/
interaction_rule(
    (hacl(IP1,IP2,_,_) :-
        ipInSameVLAN(IP1,IP2),
        localAccessEnabled(IP1,IP2,Port)),
    rule_desc('Access enabled between hosts in same vlan',
   1.0)).
   
interaction_rule(
    (hacl(IP1,IP2,Protocol,Port) :-
        vlanToVlan(Vlan1,Vlan2,Protocol,Port),
        Vlan1 \== Vlan2 ,
        isInVlan(IP1,Vlan1),
        isInVlan(IP2,Vlan2)),
    rule_desc('Access across VLANs',
   1.0)). /*Access across VLANs*/

interaction_rule(
    (hacl(IP1,IP2,Protocol,Port) :-
        ipToVlan(IP1,Vlan,Protocol,Port),
        isInVlan(IP2,Vlan)),
    rule_desc('Access to VLAN',
   1.0)).  
   
   
interaction_rule(
    (hacl(IP1,IP2,Protocol,Port) :-
        vlanToIP(Vlan,IP2,Protocol,Port),
        isInVlan(IP1,Vlan)),
    rule_desc('Access from VLAN',
   1.0)).
   
   
interaction_rule(
  (localAccessEnabled(FromIP,ToIP,_) :-
	defaultLocalFilteringBehavior(ToIP, allow)),
  rule_desc('No local filtering on this host',
  1.0)).
  
interaction_rule(
  (localAccessEnabled(FromIp,ToIP,Port) :-
	localFilteringRule(FromIP,ToIP,Port, allow)),
  rule_desc('Local filtering allow this access',
  1.0)).  




/* primitive predicates declaration */

primitive(vmOnHost(_vm,_host,_software,_user)).
primitive(vmInDomain(_vm,_orchestrator)).
primitive(vnfOnPath(_vnf,_host1,_host2,_port,_daemon,_user)).
primitive(localServiceInfo(_servicename, _host, _program, _user)).

/* derived predicates declaration */

derived(execCode(_host,_user)).
derived(accessFile(_machine, _access, _filepath)).
derived(orchestratorCompromised(_orchestrator)).

/* tabling predicates */

:- table execCode/1.
:- table execCode/2.
:- table execCode/4.
:- table accessFile/2.
:- table orchestratorCompromised/2.

/* interaction rules */

interaction_rule(
	(execCode(Hypervisor, User) :-
		execCode(Vm, _), vmOnHost(Vm, Hypervisor, Software, User), vulExists(Hypervisor, Vuln, Software), vulProperty(Vuln, localExploit, privEscalation)),
	rule_desc('can escape from VM to host', 1)).
	
interaction_rule(
	(execCode(Hypervisor, User) :-
		execCode(Vm, _), vmOnHost(Vm, Hypervisor, Software, User), vulExists(Hypervisor, Vuln, Software, localExploit, privEscalation)),
	rule_desc('can escape from VM to host', 1)).

interaction_rule(
	(execCode(Host, User) :-
		execCode(Host, root), User \== root),
	rule_desc('root can impersonate any user', 1)).

interaction_rule(
	(execCode(Vm, root) :-
		vmOnHost(Vm, Hypervisor, _, User), execCode(Hypervisor, User)),
	rule_desc('VM runs on compromised host so it is compromised', 1)).

interaction_rule(
	(accessFile(Vm, _, _) :-
		vmOnHost(Vm, Hypervisor, _, User), execCode(Hypervisor, User)),
	rule_desc('Can access VM filesystem through hypervisor', 1)).

/* Trojan rule : to complete*/
/*interaction_rule*/
/*	(execCode(Vm, root) :-*/
/*		vmOnHost(Vm, Hypervisor, _, User), accessFile(Vm, write, _)),*/
/*	rule_desc('Can install trojan on VM', 1)).*/

interaction_rule(
	(orchestratorCompromised(Orchestrator) :-
		localServiceInfo(Orchestrator, Host, Program, User), execCode(Host, User)),
	rule_desc('Can take over orchestrator from its host', 1)).

interaction_rule(
	(execCode(Vm, root) :-
		vmInDomain(Vm, Orchestrator), orchestratorCompromised(Orchestrator)),
	rule_desc('Host controlled by compromised orchestrator or controller', 1)).

interaction_rule(
	(execCode(Vnf, User) :-
		vnfOnPath(Vnf, Host1, Host2, Port, Software, User), execCode(Host1, _), vulExists(Vnf, Vuln, Software), vulProperty(Vuln, vnfExploit, privEscalation)),
	rule_desc('can execute code on VNF 3 party interaction rule', 1)).

/************************************/
/*              NDN                 */
/************************************/

/* primitive predicates declaration */

primitive(hasNDNFace(_host, _face)).
primitive(faceIsLinked(_faceA, _faceB)).
primitive(isNDNRouter(_host)).
primitive(isIGWSoftware(_software)).
primitive(ndnServiceInfo(_host, _software, _user)).

/* derived predicates declaration */

derived(ndnLink(_host1, _host2)).
derived(execCode(_host, _user)).
derived(ndnOutputCompromisedSigned(_ndnRouter)).
derived(ndnOutputCompromisedUnsigned(_ndnRouter)).
derived(ndnTrafficIntercepted(_ndnRouter)).

/* tabling predicates */

:- table ndnLink/3.
:- table ndnOutputCompromisedSigned/5.
:- table ndnOutputCompromisedSigned/3.
:- table ndnOutputCompromisedUnsigned/1.
:- table ndnOutputCompromisedSigned/1.
:- table ndnOutputCompromisedUnsigned/5.
:- table execCode/5.
:- table netAccess/5.
:- table ndnTrafficIntercepted/5.

/* interaction rules */

/* NDN Link (in both directions, assuming NDN links are symetric */

interaction_rule(
        (ndnLink(Host1, Host2) :-
                hasNDNFace(Host1, Face1),
                hasNDNFace(Host2, Face2),
                faceIsLinked(Face1, Face2)),
        rule_desc('Direct NDN link exists between hosts', 1.0)).
        
interaction_rule(
        (ndnLink(Host1, Host2) :-
                hasNDNFace(Host1, Face1),
                hasNDNFace(Host2, Face2),
                faceIsLinked(Face2, Face1)),
        rule_desc('Direct NDN link exists between hosts', 1.0)).

/* Input compromised and signed -> output compromised signed (CACHE POISONING With FAKE DATA) */

interaction_rule(
        (ndnOutputCompromisedSigned(NDNRouter1) :-
                ndnLink(NDNRouter1, NDNRouter2),
                isNDNRouter(NDNRouter1),
                ndnOutputCompromisedSigned(NDNRouter2)),
         rule_desc('NDN router transfers signed but compromised data', 1.0)).

/* Input compromised and unsigned + don't check signature -> output compromised and unsigned (CACHE POISONNING With CORRUPTED DATA) */

interaction_rule(
        (ndnOutputCompromisedUnsigned(NDNRouter1) :-
                ndnLink(NDNRouter1, NDNRouter2),
                isNDNRouter(NDNRouter1),
                ndnOutputCompromisedUnsigned(NDNRouter2),
                vulExists(NDNRouter1, Vuln, Software),
                vulProperty(Vuln, signatureExploit, cachePoisonned)),
         rule_desc('NDN router can transfer unsigned and compromised data', 1.0)).

/* Input compromised and signed + vulnerability -> execCode (CACHE POISONNING With FAKE DATA) */

interaction_rule(
        (execCode(NDNRouter1, User) :-
		        ndnLink(NDNRouter1, NDNRouter2),
                ndnOutputCompromisedSigned(NDNRouter2),
                ndnServiceInfo(NDNRouter1, Software, User),
                vulExists(NDNRouter1, Vuln, Software),
                vulProperty(Vuln, remoteExploit, privEscalation)),
        rule_desc('Can execute code on router', 1.0)).

/* Input compromised and unsigned + vulnerability -> execCode (CACHE POISONNING With CORRUPTED DATA) */

interaction_rule(
        (execCode(NDNRouter1, User) :-
		        ndnLink(NDNRouter1, NDNRouter2),
                ndnOutputCompromisedUnsigned(NDNRouter2),
                ndnServiceInfo(NDNRouter1, Software, User),
                vulExists(NDNRouter1, Vuln, Software),
                vulProperty(Vuln, remoteExploit, privEscalation)),
        rule_desc('Can execute code on router', 1.0)).

/* execCode -> output compromised and signed (FAKE DATA) */

interaction_rule(
        (ndnOutputCompromisedSigned(Host) :-
                execCode(Host, User)),
        rule_desc('Attacker can modify data sent by host or router', 1.0)).

/* execCode -> output compromised and unsigned (CORRUPTED DATA) */

interaction_rule(
        (ndnOutputCompromisedUnsigned(Host) :-
                execCode(Host, User)),
        rule_desc('Attacker can modify data sent by host or router', 1.0)).

/* malicious packets crossing the IGW in the direction IP -> NDN */ 
interaction_rule(
        (ndnOutputCompromisedSigned(Host) :-
                hasIP(Host, IP),
                netAccess(IP, Protocol, Port),
                networkServiceInfo(IP, Software, Protocol, Port, _),
                isIGWSoftware(Software)),
        rule_desc('Attacker can cross IGW from IP to NDN domain', 1.0)).

/* malicious packets crossing the IGW in the direction IP -> NDN */ 
interaction_rule(
        (ndnOutputCompromisedUnsigned(Host) :-
                hasIP(Host, IP),
                netAccess(IP, Protocol, Port),
                networkServiceInfo(IP, Software, Protocol, Port, _),
                isIGWSoftware(Software)),
        rule_desc('Attacker can cross IGW from IP to NDN domain', 1.0)).
                
/* malicious packets crossing the EGW in the direction NDN -> IP */
interaction_rule(
        (netAccess(IP, Protocol, Port) :-
                hasIP(Host, IPGW),
                hacl(IPGW, IP, Protocol, Port),
                ndnServiceInfo(Host, Software, _),
                ndnLink(Host, Host2),
                ndnOutputCompromisedSigned(Host2)),
        rule_desc('Attacker can cross EGW from NDN to IP domain', 1.0)).
        
/* malicious packets crossing the EGW in the direction NDN -> IP */
interaction_rule(
        (netAccess(IP, Protocol, Port) :-
                hasIP(Host, IPGW),
                hacl(IPGW, IP, Protocol, Port),
                ndnServiceInfo(Host, Software, _),
                ndnLink(Host, Host2),
                ndnOutputCompromisedUnsigned(Host2)),
        rule_desc('Attacker can cross EGW from NDN to IP domain', 1.0)).

/* routers replying to interest from another face (signed version) */
interaction_rule(
        (ndnOutputCompromisedSigned(Host) :-
                ndnLink(Host, Host2),
                ndnLink(Host, Host3),
                Host2 \== Host3,
                execCode(Host3, _),
                isNDNRouter(Host),
                vulExists(Host, Vuln, Software),
                vulProperty(Vuln, pitExploit, cachePoisonned)),
        rule_desc('Attacker can send replies to interests issued to another interface', 1.0)).
        
/* routers replying to interest from another face (unsigned version) */
interaction_rule(
        (ndnOutputCompromisedUnsigned(Host) :-
                ndnLink(Host, Host2),
                ndnLink(Host, Host3),
                Host2 \== Host3,
                execCode(Host3, _),
                isNDNRouter(Host),
                vulExists(Host, Vuln, Software),
                vulProperty(Vuln, pitExploit, cachePoisonned)),
        rule_desc('Attacker can send replies to interests issued to another interface', 1.0)).
        
/* routers accepting FIB announcements without signature verification */        
interaction_rule(
        (ndnTrafficIntercepted(Host) :-
                ndnLink(Host, Host2),
                execCode(Host2, _),
                isNDNRouter(Host),
                vulExists(Host, Vuln, Software),
                vulProperty(Vuln, fibExploit, corruptFib)),
        rule_desc('Attacker can redirect router upstream to controlled router to intercept traffic', 1.0)).
        
        
/* IFA : Problem : IFA does not permit to corrupt data or propagate attack */

